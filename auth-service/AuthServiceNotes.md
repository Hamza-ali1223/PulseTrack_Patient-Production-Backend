# Auth Service & JWT Notes üß†

> Centralized Auth-Service + API Gateway (microservices)
> vs
> ‚ÄúAll-in-one‚Äù JWT auth (monolith)

These are your notes to remember **what you built**, **why**, and **how to rebuild it from scratch later**.

---

## 0. Why JWT at all?

**Problem:**
You need a way to tell your backend **‚Äúwho is this user?‚Äù** on every request **without**:

* storing sessions on the server
* hitting the database on every request just to check identity

**JWT idea (JSON Web Token):**

* On login, backend returns a **signed token**
* Token contains:

    * `sub` (subject) ‚Üí who the user is (in your case: **email**)
    * claims ‚Üí extra info (`role`, `id`, etc.)
* Client sends this token on every request in `Authorization: Bearer <token>`
* Server validates signature ‚Üí if valid, trusts the info inside

---

## 1. Two Worlds: Monolith vs Microservices

### 1.1. Monolith JWT Architecture

Everything is in **one application**:

* `/auth/login` ‚Üí app checks credentials ‚Üí issues JWT
* For every request:

    * JWT filter runs inside the same app
    * Filter validates token + sets `SecurityContext`
    * Controllers read user from `SecurityContextHolder`

**One codebase does:**

1. Credentials check
2. JWT issuing
3. JWT validation
4. Business logic

---

### 1.2. Microservices JWT Architecture

You split responsibilities across services.

#### Roles:

* **Auth-Service**

    * Knows about users and passwords
    * Handles **signup** and **login**
    * Issues JWT tokens

* **API Gateway**

    * Front door to your system
    * Validates JWT on every request
    * Does **not** know passwords
    * Forwards only valid requests to backend services

* **Business Microservices** (patient-service, billing-service, etc.)

    * Do business logic only
    * Trust information from gateway
    * May not use Spring Security at all (or only for internal authorization)

---

### 1.3. High-level flows

#### Microservices ‚Äì Login + subsequent request

**Login:**

1. Client ‚Üí `POST /auth/login` (Auth-Service)
2. Auth-Service:

    * checks email + password
    * creates JWT (`sub=email`, `role=USER/ADMIN`)
    * returns token
3. Client stores token (in memory/local storage etc.)

**Calling another service:**

1. Client ‚Üí `GET /patient/123` via Gateway
   with header: `Authorization: Bearer <token>`
2. Gateway:

    * validates JWT signature
    * parses claims (`email`, `role`)
    * builds Authentication object
    * (optional) attaches headers like `X-User-Email`
    * forwards request to patient-service
3. Patient-service:

    * receives a request already verified by gateway
    * just runs business logic

---

## 2. Your Auth-Service Design (Microservices World)

You built a **centralized auth-service** that does 2 things:

1. **Registration (signup)**
2. **Login ‚Üí issue JWT**

You decided that:

* **Email is the unique identity**
* ‚ÄúUsername‚Äù is not important for authentication
* Everywhere Spring Security talks about ‚Äúusername‚Äù, you treat it as **email**

---

### 2.1. User Entity (email as principal)

```java
@Entity
@Table(name = "users")
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(unique = true, nullable = false)
    private String email;      // used as principal

    private String userName;   // just display, not used for auth

    @Column(nullable = false)
    private String password;   // BCrypt hash

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    public enum Role {
        USER,
        ADMIN
    }

    // --- UserDetails methods ---

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority(role.name()));
    }

    // Spring Security ‚Äúusername‚Äù -> your email
    @Override
    public String getUsername() {
        return this.email;
    }

    // getPassword() is generated by Lombok (@Data), or you could write it manually
}
```

**Key point:**
Spring Security expects `getUsername()`.
You decided `getUsername()` returns **email**.
So to Spring Security, **email IS username**.

---

### 2.2. UserRepository

```java
public interface UserRepository extends JpaRepository<User, UUID> {

    // email is unique identifier
    Optional<User> findUserByEmail(String email);
}
```

This is used:

* in signup ‚Üí to check if user already exists
* in login ‚Üí to find user after successful authentication (or for manual password check)

---

### 2.3. CustomUserDetailsService ‚Äì how Spring fetches a user

```java
@Service
public class CustomUserDetailsService implements UserDetailsService {

    private final UserRepository userRepository;

    public CustomUserDetailsService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // Spring calls this during authentication
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        return userRepository.findUserByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + email));
    }
}
```

**Mental model:**
When `AuthenticationManager` authenticates a login, it uses:

* `loadUserByUsername(email)` ‚Üí load your `User` entity
* Then compares passwords using the configured `PasswordEncoder`.

Because `getUsername()` on your entity returns `email`, everything lines up.

---

### 2.4. SecurityConfig ‚Äì stateless, DaoAuthenticationProvider

```java
@Configuration
public class SecurityConfig {

    private final CustomUserDetailsService userDetailsService;

    public SecurityConfig(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session ->
                    session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .authorizeHttpRequests(auth -> auth
                    .requestMatchers("/auth/register", "/auth/login").permitAll()
                    .anyRequest().authenticated()
            )
            .authenticationProvider(daoAuthenticationProvider());

        // No JWT validation filter: this service only issues tokens.
        return http.build();
    }

    @Bean
    public DaoAuthenticationProvider daoAuthenticationProvider() {
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        provider.setUserDetailsService(userDetailsService);
        provider.setPasswordEncoder(passwordEncoder());
        return provider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config)
            throws Exception {
        return config.getAuthenticationManager();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

**Key ideas:**

* `SessionCreationPolicy.STATELESS` ‚Üí no server sessions
* `DaoAuthenticationProvider`:

    * uses `CustomUserDetailsService` ‚Üí loads user by email
    * uses `PasswordEncoder` ‚Üí compares raw password with stored hash
* `/auth/register` and `/auth/login` are open, everything else protected (for now)

---

### 2.5. JwtService ‚Äì how tokens are generated

```java
@Service
public class JwtService {

    private final SecretKey secretKey;
    private final long expirationMillis;

    public JwtService(@Value("${jwt.secret}") String secret,
                      @Value("${jwt.expiration-millis}") long expirationMillis) {
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes());
        this.expirationMillis = expirationMillis;
    }

    public String generateToken(String email, String role) {
        long now = System.currentTimeMillis();
        Date issuedAt = new Date(now);
        Date expiration = new Date(now + expirationMillis);

        return Jwts.builder()
                .setSubject(email)          // sub = email (your principal)
                .setIssuedAt(issuedAt)
                .setExpiration(expiration)
                .claim("role", role)        // claim = role
                .signWith(secretKey, SignatureAlgorithm.HS256)
                .compact();
    }
}
```

**Important:**

* `sub` (subject) = **email** ‚Üí the identity
* `role` claim = authorization info
* Signed with a secret so nobody can fake it

---

### 2.6. AuthService ‚Äì registration + login logic

#### Registration flow (signup)

```java
@Service
public class AuthService {

    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepo;
    private final PasswordEncoder passwordEncoder;
    private final JwtService jwtService;

    public AuthService(AuthenticationManager authenticationManager,
                       UserRepository userRepo,
                       PasswordEncoder passwordEncoder,
                       JwtService jwtService) {
        this.authenticationManager = authenticationManager;
        this.userRepo = userRepo;
        this.passwordEncoder = passwordEncoder;
        this.jwtService = jwtService;
    }

    public void register(RegisterRequest request) {
        boolean exists = userRepo.findUserByEmail(request.getEmail()).isPresent();
        if (exists) {
            throw new UserAlreadyExistsException(request.getEmail());
        }

        User user = User.builder()
                .email(request.getEmail())
                .userName(request.getUserName())
                .password(passwordEncoder.encode(request.getPassword()))
                .role(User.Role.USER) // or from request if you want
                .build();

        userRepo.save(user);
    }
}
```

**Flow in your head:**

* Does a user with this email already exist?

    * yes ‚Üí exception
    * no ‚Üí hash password, save user

No JWT here unless you want auto-login after signup.

---

#### Login flow

Two options:

##### Option A ‚Äì Use AuthenticationManager

```java
public String login(LoginRequest request) {

    // This does: loadUserByUsername(email) + password check
    Authentication auth = authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(
                    request.getEmail(),
                    request.getPassword()
            )
    );

    // If we reach here, credentials are valid.
    User user = userRepo.findUserByEmail(request.getEmail())
            .orElseThrow(() -> new RuntimeException("User not found"));

    return jwtService.generateToken(user.getEmail(), user.getRole().name());
}
```

##### Option B ‚Äì Manual password check

```java
public String login(LoginRequest request) {

    User user = userRepo.findUserByEmail(request.getEmail())
            .orElseThrow(() -> new RuntimeException("User not found"));

    if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {
        throw new InvalidCredentialsException();
    }

    return jwtService.generateToken(user.getEmail(), user.getRole().name());
}
```

**Core rule:**
‚úî Always verify **email + password** before generating a JWT.

---

### 2.7. AuthController ‚Äì just a thin wrapper

```java
@RestController
@RequestMapping("/auth")
public class AuthController {

    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @PostMapping("/register")
    public ResponseEntity<Void> register(@RequestBody RegisterRequest request) {
        authService.register(request);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@RequestBody LoginRequest request) {
        String token = authService.login(request);
        return ResponseEntity.ok(new AuthResponse(token));
    }
}
```

---

## 3. API Gateway (Microservices) ‚Äì Where JWT is validated

You haven‚Äôt fully wired this yet, but conceptually:

1. Gateway has its own `SecurityConfig`
2. You add a **JWT filter** (e.g. `OncePerRequestFilter`) before `UsernamePasswordAuthenticationFilter`
3. Filter:

    * Reads `Authorization` header
    * Extracts token
    * Validates token with same secret
    * If valid:

        * builds `UsernamePasswordAuthenticationToken` with:

            * principal = email
            * authorities = role
        * sets it into `SecurityContextHolder`
4. Spring Security at gateway level can then do:

    * `.hasRole("ADMIN")`
    * `.authenticated()` checks

Only after this does gateway forward the request to downstream services.

**Difference from monolith:**
In monolith the **same app** both validates token and runs controllers.
In microservices, the **gateway** validates, but your business microservices just receive already-validated traffic.

---

## 4. Monolith JWT Mind Map üß©

If you were doing a monolith again:

1. **User entity + repository** (same as now)
2. **CustomUserDetailsService** (same)
3. **SecurityConfig**

    * stateless
    * permit `/auth/login`
    * protect everything else
    * **add JWT filter** that validates tokens
4. **AuthController + AuthService**

    * login ‚Üí validate credentials ‚Üí generate JWT
5. **JWT filter on every request**:

    * validate token
    * fill SecurityContext
    * proceed to controller

Everything happens inside one app.

---

## 5. Microservices JWT Mind Map üß©

* **Auth-Service**

    * Registration: create user row
    * Login:

        * verify email + password
        * generate JWT (`sub=email`, claim `role`)
    * No JWT filter, no token validation

* **API Gateway**

    * Has JWT filter
    * Validates tokens
    * Does route-based authorization
    * Forwards request to internal microservices

* **Other Services**

    * No password storage
    * No login endpoints
    * Only business logic

---

## 6. Quick Checklist: ‚ÄúImplement JWT With Central Auth-Service‚Äù

1. Decide your principal ‚Üí **email** ‚úÖ
2. User entity:

    * `email` unique + not null
    * `password` (BCrypt hashed)
    * `role` (enum/string)
3. Repository: `findUserByEmail`
4. CustomUserDetailsService: `loadUserByUsername(email)` ‚Üí use repository
5. SecurityConfig:

    * Stateless
    * DaoAuthenticationProvider with your userDetails + encoder
    * Expose AuthenticationManager
6. JwtService:

    * `sub = email`
    * `role` claim
7. AuthService:

    * `register()` ‚Üí check existing email, hash password, save
    * `login()` ‚Üí verify credentials, generate JWT
8. AuthController:

    * `/auth/register`
    * `/auth/login`
9. Later: Gateway with JWT validation filter.

---
## Tip ‚Äì Role-Based Rules with `enum Role { USER, ADMIN }` üõ°Ô∏è

This tip is about **how roles move through the whole system**:

1. From your **`Role` enum**
2. Into the **database**
3. Into **Spring Security authorities**
4. Into the **JWT**
5. Into **gateway access rules** (`hasRole` / `hasAuthority`)

So you can say:

> ‚ÄúOnly ADMINs can hit these endpoints; USERs can only hit those.‚Äù

---

## 1. Role Enum + JPA Mapping

You decided roles are simple:

```java
public enum Role {
    USER,
    ADMIN
}
```

In the `User` entity:

```java
@Entity
@Table(name = "users")
public class User implements UserDetails {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private UUID id;

    @Column(unique = true, nullable = false)
    private String email;

    @Column(nullable = false)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role;

    // ...
}
```

### What this does:

* `EnumType.STRING` means the DB will store:

    * `"USER"` or `"ADMIN"`
* It‚Äôs **human-readable** and **safe** if you add more roles later (no ordinal issues).

So in the DB you‚Äôll literally see a `role` column with values `USER` or `ADMIN`.

---

## 2. Turning `Role` into Spring Security Authorities

Spring Security doesn‚Äôt work with enums directly; it works with **`GrantedAuthority` strings**.

You already have something like:

```java
@Override
public Collection<? extends GrantedAuthority> getAuthorities() {
    return List.of(new SimpleGrantedAuthority(this.role.name()));
}
```

This gives you authorities like:

* `"USER"`
* `"ADMIN"`

There are **two common patterns** you can choose from:

### üîπ Option A ‚Äì Use `ROLE_` prefix + `hasRole(...)`

```java
@Override
public Collection<? extends GrantedAuthority> getAuthorities() {
    return List.of(new SimpleGrantedAuthority("ROLE_" + this.role.name()));
}
```

This produces:

* `ROLE_USER`
* `ROLE_ADMIN`

Then you can use:

```java
.requestMatchers("/admin/**").hasRole("ADMIN")     // looks for ROLE_ADMIN
.requestMatchers("/user/**").hasAnyRole("USER", "ADMIN")
```

### üîπ Option B ‚Äì No prefix, use `hasAuthority(...)`

Keep your existing `getAuthorities()`:

```java
@Override
public Collection<? extends GrantedAuthority> getAuthorities() {
    return List.of(new SimpleGrantedAuthority(this.role.name())); // USER / ADMIN
}
```

Then use:

```java
.requestMatchers("/admin/**").hasAuthority("ADMIN")
.requestMatchers("/user/**").hasAnyAuthority("USER", "ADMIN")
```

> **Pick ONE style and stick to it everywhere.**
> Personally, I‚Äôd pick **Option A with `ROLE_`** because it‚Äôs the classic Spring style and works nicely with `hasRole`.

---

## 3. Putting the Role into the JWT

When login succeeds, you generate a token. You‚Äôre already doing:

```java
String token = jwtService.generateToken(user.getEmail(), user.getRole().name());
```

Inside `JwtService`:

```java
public String generateToken(String email, String role) {
    long now = System.currentTimeMillis();
    Date issuedAt = new Date(now);
    Date expiration = new Date(now + expirationMillis);

    return Jwts.builder()
            .setSubject(email)       // identity: email
            .setIssuedAt(issuedAt)
            .setExpiration(expiration)
            .claim("role", role)     // "USER" or "ADMIN"
            .signWith(secretKey, SignatureAlgorithm.HS256)
            .compact();
}
```

So each JWT contains:

* `sub`  ‚Üí `"user@example.com"`
* `role` ‚Üí `"USER"` or `"ADMIN"`

This is enough for **any service** (gateway, microservice) to reconstruct the user‚Äôs role.

---

## 4. Using Role in the API Gateway (Route Rules)

Later, in your **API Gateway** when you write your own JWT validation filter:

1. Parse the token
2. Extract:

    * `email` from `subject`
    * `role` from `"role"` claim
3. Create authorities from that role

Example if you follow **Option A (ROLE_ prefix)**:

```java
String email = claims.getSubject();             // email
String role  = claims.get("role", String.class); // "USER" / "ADMIN"

// Build authority: ROLE_USER / ROLE_ADMIN
SimpleGrantedAuthority authority =
        new SimpleGrantedAuthority("ROLE_" + role);

UsernamePasswordAuthenticationToken auth =
        new UsernamePasswordAuthenticationToken(
                email,
                null,
                List.of(authority)
        );

SecurityContextHolder.getContext().setAuthentication(auth);
```

Then in your **gateway SecurityConfig**:

```java
http
    .authorizeHttpRequests(auth -> auth
        .requestMatchers("/auth/**").permitAll()
        .requestMatchers("/admin/**").hasRole("ADMIN")          // needs ROLE_ADMIN
        .requestMatchers("/patient/**").hasAnyRole("USER", "ADMIN")
        .anyRequest().authenticated()
    );
```

Now the flow is:

* If JWT has `role=ADMIN` ‚Üí authority = `ROLE_ADMIN` ‚Üí can access `/admin/**`
* If JWT has `role=USER` ‚Üí authority = `ROLE_USER` ‚Üí can access `/patient/**` (if rules allow), but NOT `/admin/**`

---

## 5. Using Role Inside Microservices (Optional)

You have two options:

### Option 1 ‚Äì Gateway only (simpler)

* Gateway fully handles JWT + authorization.
* Microservices just assume ‚Äúif it reached me, it‚Äôs already allowed‚Äù.
* You might forward role/email via headers:

```http
X-User-Email: user@example.com
X-User-Role: USER
```

### Option 2 ‚Äì Also enforce roles inside microservices

If you propagate the token to microservices and validate it there too, you can use annotations like:

```java
@PreAuthorize("hasRole('ADMIN')")
@GetMapping("/admin/stats")
public ResponseEntity<?> adminOnlyStats() { ... }
```

or

```java
@PreAuthorize("hasAuthority('ADMIN')")
```

depending on whether you chose `ROLE_` prefix or not.

This is more complex but gives defense-in-depth.

---

## 6. Quick Mental Model: Roles from DB ‚Üí JWT ‚Üí Gateway ‚Üí Access

1. **DB**

    * `role` column: `"USER"` or `"ADMIN"` (from enum `Role`)

2. **UserDetails / Authorities**

    * Map `Role` to `SimpleGrantedAuthority`
    * Decide style:

        * `"ROLE_USER"` / `"ROLE_ADMIN"` + `hasRole`
        * or `"USER"` / `"ADMIN"` + `hasAuthority`

3. **JWT Issuing (Auth-Service)**

    * `sub = email`
    * `role = "USER" / "ADMIN"`

4. **JWT Validation (Gateway)**

    * Verify signature
    * Extract `email`, `role`
    * Build `Authentication` with the correct authority
    * Use `hasRole` / `hasAuthority` to protect routes.

Once this clicks, **role-based access** across microservices becomes very straightforward:
you‚Äôre just passing a tiny piece of info (`role`) from DB ‚Üí token ‚Üí gateway ‚Üí access rules.

